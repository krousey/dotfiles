* Bootstrap

#+BEGIN_SRC emacs-lisp 
  ;; Do not modify this file manually. It was generated from init.org in the same
  ;; directory. Edit that instead.
#+END_SRC

I use use-package throughout, so let's make sure that it's installed and loaded.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/") t)
  
  (package-initialize)
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
#+END_SRC

I also want to use :diminish with use-package.

#+BEGIN_SRC emacs-lisp
  (use-package diminish :ensure t)
#+END_SRC

* Look and feel
** Color theme
#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :config (load-theme 'sanityinc-tomorrow-night t))
#+END_SRC

** Fonts and syntax

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
  (add-to-list 'default-frame-alist '(tool-bar-lines . 0))
  (add-to-list 'default-frame-alist 
               '(font . "-unknown-Inconsolata-normal-normal-normal-*-11-*-*-*-m-0-iso10646-1"))
#+END_SRC emacs-lisp

** Miscellaneous

Reduce the clutter.
#+BEGIN_SRC emacs-lisp 
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  
  (setq window-min-height 3
        column-number-mode t
        mouse-avoidance-mode 'jump)
#+END_SRC
* General behavior
** Autosaves and backups

Put them all in the temp directory

#+BEGIN_SRC emacs-lisp
  (defconst my/emacs-tmp-dir
    (concat temporary-file-directory "emacs_" (user-login-name) "/")
    "Temp directory for me.")
  
  (setq backup-directory-alist         `((".*" . ,my/emacs-tmp-dir))
        auto-save-file-name-transforms `((".*" ,my/emacs-tmp-dir t))
        auto-save-list-file-prefix     my/emacs-tmp-dir)
#+END_SRC

** Company mode
Code completion

#+BEGIN_SRC emacs-lisp 
  (use-package company
    :ensure t
    :commands (company-mode global-company-mode)
    :diminish company-mode
    :config
    (setq company-minimum-prefix-length 2))
  
  (use-package company-go
    :ensure t
    :commands company-mode)
#+END_SRC

** Compilation
#+BEGIN_SRC emacs-lisp
  (use-package compile
    :config
    (setq compilation-scroll-output 'first-error))
#+END_SRC
** Eshell

#+BEGIN_SRC emacs-lisp
  (use-package eshell
    :commands eshell
    :init
    (defvar my/eshell-prompt-client-path-functions nil
      "A list of functions that take a path and return a list of
  client name and remaining path")
  
    (defun my/eshell-prompt ()
      (let ((path (eshell/pwd))
            (client nil))
        ;; See if our path contains any code clients
        (loop
         for f in my/eshell-prompt-client-path-functions
         while (not client)
         do
         (let ((result (funcall f path)))
           (when result
             (setq client (car result)
                   path (car (cdr result))))))
        (let ((prompt
               ;; user@system [client/]short_path >
               (concat
                (propertize (user-real-login-name)
                            'face '(:weight bold :foreground "SteelBlue2"))
                (propertize "@"
                            'face '(:weight bold :foreground "light sea green"))
                (propertize (car (split-string (system-name) "\\."))
                            'face '(:weight bold :foreground "white"))
                " "
                (when client (propertize client
                                         'face '(:weight bold :foreground "red")))
                (propertize (my/shortened-path path 40)
                            'face '(:weight bold :foreground "light sea green"))
                (if (= (user-uid) 0) " $ " " > "))))
          ;; now make it read-only
          (add-text-properties
           0 (length prompt)
           '(read-only t front-sticky (face read-only) rear-nonsticky (face read-only))
           prompt)
          prompt)))
  
    (defun my/shortened-path (path max-len)
      "Return a modified version of `path', replacing some components
   with single characters starting from the left to try and get
   the path down to `max-len'"
      (let* ((components (split-string (abbreviate-file-name path) "/"))
             (len (+ (1- (length components))
                     (reduce '+ components :key 'length)))
             (str ""))
        (while (and (> len max-len)
                    (cdr components))
          (setq str (concat str (if (= 0 (length (car components)))
                                    "/"
                                  (string (elt (car components) 0) ?/)))
                len (- len (1- (length (car components))))
                components (cdr components)))
        (concat str (reduce (lambda (a b) (concat a "/" b)) components))))
  
    (setq eshell-prompt-regexp "^[^>$\n]* [>$] ")
    (setq eshell-highlight-prompt nil)
    (setq eshell-prompt-function 'my/eshell-prompt))
    
#+END_SRC

** Evil mode
VIM emulation

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config
    (setq evil-default-cursor t)
    (evil-mode 1))
  
  (use-package key-chord  
    :ensure t
    :config
    (key-chord-mode 1)
    (setq key-chord-two-keys-delay 0.2)
    (key-chord-define evil-normal-state-map "jk" 'evil-force-normal-state)
    (key-chord-define evil-visual-state-map "jk" 'evil-change-to-previous-state)
    (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
    (key-chord-define evil-replace-state-map "jk" 'evil-normal-state))
  
  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))
  
  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode t)
    (evil-leader/set-leader "<SPC>"))
  
  (use-package evil-nerd-commenter
    :ensure t
    :config
    (eval-after-load "evil-leader"
      (evil-leader/set-key
        "; i" 'evilnc-comment-or-uncomment-lines
        "; l" 'evilnc-comment-or-uncomment-to-the-line
        "; c" 'evilnc-copy-and-comment-lines
        "; p" 'evilnc-comment-or-uncomment-paragraphs
        "; r" 'comment-or-uncomment-region)))
#+END_SRC

** Flycheck
Continuous checking

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :commands flycheck-mode
    :config
    (setq flycheck-highlighting-mode nil))
#+END_SRC
 
** IDO

#+BEGIN_SRC emacs-lisp 
  (use-package ido
    :ensure t
    :config
    (setq ido-enable-tramp-completion nil
          ido-max-work-file-list nil
          ido-max-work-directory-list nil)
    (ido-mode t)
    (ido-everywhere)
    (setq ido-enable-flex-matching t))
  
  (use-package ido-ubiquitous
    :ensure t
    :config
    (ido-ubiquitous-mode 1))
#+END_SRC
** Ibuffer

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :ensure t
    :commands (ibuffer ibuffer-other-window)
    :config
    ;; short mode names
    (define-ibuffer-column mode-s
      (:name "Mode"
             :inline t
             :header-mouse-map ibuffer-mode-header-map
             :props
             ('mouse-face 'highlight
                          'keymap ibuffer-mode-name-map
                          'help-echo "mouse-2: filter by this mode"))
      (let ((mname (format-mode-line mode-name nil nil (current-buffer))))
        (cond ((> (length mname) 14)
               (format "%s..." (substring mname 0 11)))
              (t mname))))
  
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size"
             :inline t
             :header-mouse-map ibuffer-size-header-map)
      (cond
       ((> (buffer-size) 1000) (format "%6.2f K" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000000) (format "%6.2f M" (/ (buffer-size) 1000000.0)))
       (t (format "%6d  " (buffer-size)))))
  
    (setq ibuffer-formats '((mark
                             modified
                             read-only " "
                             (name 36 36) " "
                             (size-h 9 -1 :right) " "
                             (mode-s 14 14) " "
                             (process 8 -1) " "
                             (filename 16 -1 :left :elide)))
          ibuffer-saved-filter-groups '(("default"
                                         ("c" (mode . c-mode))
                                         ("c++" (mode . c++-mode))
                                         ("python" (mode . python-mode))
                                         ("haskell" (mode . haskell-mode))
                                         ("go" (mode . go-mode))
                                         ("dired" (mode . dired-mode))
                                         ("emacs" (or (name . "^\\*scratch\\*$")
                                                      (name . "^\\*Messages\\*$")
                                                      (name . "^\\*Completions\\*$")
                                                      (name . "^\\*Backtrace\\*$")
                                                      (mode . emacs-lisp-mode)))
                                         ("special" (name . "^\\*.*\\*$"))))
          ibuffer-elide-long-columns t
          ibuffer-eliding-string "&")
  
    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-auto-mode 1)
                (ibuffer-switch-to-saved-filter-groups "default")
                (let ((blist (ibuffer-current-state-list)))
                  (let ((bgroups (ibuffer-generate-filter-groups blist t)))
                    (dolist (group bgroups)
                      (let ((name (car group)))
                        (when (and (member name '("dired" "emacs" "special"))
                                   (not (member name ibuffer-hidden-filter-groups)))
                          (push name ibuffer-hidden-filter-groups))))))
                (ibuffer-update nil t)))
  
    (setq ibuffer-show-empty-filter-groups nil)
    (setq ibuffer-expert t))
#+END_SRC
** Hiding

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  
  (defun my/toggle-hiding ()
    (interactive)
    (when hs-minor-mode
        (if (condition-case nil
                (hs-toggle-hiding)
              (error t))
            (hs-show-all))))
  
  (global-set-key (kbd "C-c h") 'my/toggle-hiding)
  (eval-after-load "evil-leader"
    (evil-leader/set-key "h" 'my/toggle-hiding))
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :init
    (setq magit-last-seen-setup-instructions "1.4.0")
    :config
    (setq magit-auto-revert-mode nil))
#+END_SRC

** Miscellaneous
#+BEGIN_SRC emacs-lisp
  (setq enable-local-eval t)
  (setq default-major-mode 'text-mode)
  (setq x-select-enable-clipboard t)
#+END_SRC
** Popwin
#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :ensure t
    :config
    (push '(compilation-mode :noselect t :stick t :position bottom)
          popwin:special-display-config)
    (push '("*Gofmt Errors*" :noselect t :position bottom)
          popwin:special-display-config)
    (popwin-mode 1))
  
  (use-package import-popwin
    :ensure t
    :config
    (import-popwin:add :mode 'java-mode
                       :regexp "^import\\s")
    (import-popwin:add :mode 'go-mode
                       :regexp "^import\\s"))
#+END_SRC
** Smex
#+BEGIN_SRC emacs-lisp
  (use-package smex
    :ensure t
    :config
    (smex-initialize))
#+END_SRC
** Uniquify
#+BEGIN_SRC emacs-lisp
  (use-package uniquify
    :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets)
    (setq uniquify-after-kill-buffer-p t))
    
#+END_SRC
** Whichfunc
#+BEGIN_SRC emacs-lisp
  (use-package which-func
    :config
    (setq-default header-line-format
                  '((which-func-mode ("" which-func-format " "))))
    (setq which-func-unknown "n/a"
          mode-line-misc-info (assq-delete-all 'which-func-mode mode-line-misc-info))
    (which-function-mode))
#+END_SRC
** YASnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1))
#+END_SRC
* Programming modes
** General
#+BEGIN_SRC emacs-lisp 
  (add-hook
   'prog-mode-hook
   (lambda ()
     ;; fix the cursor during page ups and downs
     (setq-local scroll-preserve-screen-position t)
     (setq-local scroll-margin 2)
     
     ;; show matching parenthesis
     (show-paren-mode 1)))
#+END_SRC

** Go
#+BEGIN_SRC emacs-lisp
  (use-package go-eldoc
    :ensure t
    :commands go-eldoc-setup)
  
  (use-package go-mode
    :ensure t
    :mode ("\\.go\\'" . go-mode)
    :config
    (setq gofmt-command "goimports")
  
    (defun my/setup-godep-env ()
      "Modify GOPATH locally for godep managed projects."
      (when (locate-dominating-file (buffer-file-name) "Godeps/Godeps.json")
        (set (make-local-variable 'process-environment) (append process-environment (list)))
        (let ((godep-path
               (replace-regexp-in-string
                "\n$" ""
                (shell-command-to-string "godep path"))))
          (setenv "GOPATH"
                  (concat godep-path
                          path-separator
                          (getenv "GOPATH"))))))
  
    (defun my/go-mode-hook ()
      (setup-godep-env)
      (go-eldoc-setup)
      (flycheck-mode)
      (let ((whitespace-style '(face lines-tail trailing)))
        (whitespace-mode))
      (setq-local tab-width 4)
      (setq-local company-backends '(company-go))
      (company-mode)
      (add-hook 'before-save-hook 'gofmt-before-save nil t))
  
    (add-hook 'go-mode-hook 'my/go-mode-hook)
  
    (defadvice fill-paragraph (around wrap-as-if-tabs-are-eight activate compile)
      "Wrap as if tab width is 8"
      (if (eq major-mode 'go-mode)
          (let ((tab-width 8))
            ad-do-it)
        ad-do-it)))
#+END_SRC
** Elisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (company-mode)))
#+END_SRC

* Org mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (setq org-replace-disputed-keys t)
    :mode ("\\.org\\'" . org-mode)
    :config
    (setq org-startup-indented t)
    (setq org-src-fontify-natively t)
    (setq org-src-window-setup 'other-window)
    (org-babel-do-load-languages
     (quote org-babel-load-languages)
     (quote ((emacs-lisp . t)
             (dot . t)
             (ditaa . t)
             (R . t)
             (python . t)
             (ruby . t)
             (gnuplot . t)
             (clojure . t)
             (sh . t)
             (ledger . t)
             (org . t)
             (latex . t)))))
    
#+END_SRC

;; Local Variables:
;; eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (byte-compile-file user-init-file)) nil t)
;; eval: (setq-local org-babel-default-header-args:emacs-lisp '((:comments . "org") (:tangle . "yes") (:exports . "code")))
;; End:

